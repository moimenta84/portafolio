<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Flujo de la aplicación y elección de SQLite</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: 'Calibri', 'Arial', sans-serif;
      font-size: 12pt;
      color: #1a1a1a;
      background: #fff;
      line-height: 1.7;
      padding: 60px 80px;
      max-width: 820px;
      margin: 0 auto;
    }

    h1 {
      font-size: 22pt;
      font-weight: 700;
      color: #0f172a;
      border-bottom: 3px solid #0369a1;
      padding-bottom: 10px;
      margin-bottom: 6px;
    }

    .subtitle {
      font-size: 11pt;
      color: #64748b;
      margin-bottom: 36px;
    }

    h2 {
      font-size: 14pt;
      font-weight: 700;
      color: #0369a1;
      margin-top: 32px;
      margin-bottom: 12px;
      border-left: 4px solid #0ea5e9;
      padding-left: 10px;
    }

    h3 {
      font-size: 12pt;
      font-weight: 700;
      color: #1e293b;
      margin-top: 20px;
      margin-bottom: 8px;
    }

    p {
      margin-bottom: 10px;
      text-align: justify;
    }

    ul {
      margin: 8px 0 12px 20px;
    }

    ul li {
      margin-bottom: 5px;
    }

    .flow-box {
      background: #f8fafc;
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      padding: 20px 24px;
      margin: 16px 0;
      font-family: 'Courier New', monospace;
      font-size: 10.5pt;
      line-height: 2;
      color: #334155;
    }

    .flow-box .step {
      display: flex;
      align-items: flex-start;
      gap: 12px;
      margin-bottom: 4px;
    }

    .step-num {
      background: #0369a1;
      color: white;
      font-family: 'Calibri', sans-serif;
      font-size: 9pt;
      font-weight: 700;
      border-radius: 50%;
      width: 22px;
      height: 22px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      margin-top: 2px;
    }

    .step-text {
      flex: 1;
    }

    .arrow {
      color: #0369a1;
      font-weight: bold;
      padding: 0 6px;
    }

    .highlight {
      background: #e0f2fe;
      color: #0369a1;
      padding: 1px 6px;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
      font-size: 10pt;
    }

    .decision-box {
      background: #fefce8;
      border-left: 4px solid #ca8a04;
      padding: 12px 16px;
      border-radius: 0 6px 6px 0;
      margin: 14px 0;
      font-size: 11pt;
    }

    .pro-con {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
      margin: 16px 0;
    }

    .pro, .con {
      border: 1px solid #e2e8f0;
      border-radius: 6px;
      padding: 14px 16px;
    }

    .pro { border-top: 3px solid #16a34a; }
    .con { border-top: 3px solid #dc2626; }

    .pro h4 { color: #16a34a; font-size: 11pt; margin-bottom: 8px; }
    .con h4 { color: #dc2626; font-size: 11pt; margin-bottom: 8px; }

    .pro ul, .con ul { margin-left: 16px; }
    .pro ul li, .con ul li { font-size: 10.5pt; margin-bottom: 4px; }

    .footer {
      margin-top: 50px;
      padding-top: 12px;
      border-top: 1px solid #e2e8f0;
      font-size: 9pt;
      color: #94a3b8;
      display: flex;
      justify-content: space-between;
    }

    @media print {
      body { padding: 40px 60px; }
      @page { margin: 20mm 18mm; size: A4; }
    }
  </style>
</head>
<body>

  <h1>Flujo de la aplicación y elección de SQLite</h1>
  <div class="subtitle">Iker Martínez Velasco &nbsp;·&nbsp; Proyecto Final DWEC &nbsp;·&nbsp; 2.º DAW &nbsp;·&nbsp; Curso 2025–2026</div>


  <!-- ── SECCIÓN 1 ── -->
  <h2>1. Flujo general de la aplicación</h2>

  <p>
    La aplicación sigue una arquitectura <strong>cliente-servidor</strong> donde el navegador ejecuta una
    SPA (Single Page Application) en React que se comunica con un servidor Express mediante peticiones HTTP.
    Toda la comunicación pasa por el prefijo <span class="highlight">/api</span>, tanto en desarrollo
    (mediante el proxy de Vite) como en producción (donde Express sirve también los ficheros estáticos).
  </p>

  <h3>Flujo paso a paso</h3>

  <div class="flow-box">
    <div class="step">
      <div class="step-num">1</div>
      <div class="step-text">
        El usuario abre el navegador y accede a la URL del portfolio.
        Express sirve el <strong>index.html</strong> y los ficheros estáticos del frontend compilado.
      </div>
    </div>
    <div class="step">
      <div class="step-num">2</div>
      <div class="step-text">
        React carga la SPA en el navegador. React Router determina qué página mostrar
        según la ruta (<span class="highlight">/</span>, <span class="highlight">/projects</span>,
        <span class="highlight">/newsletter</span>, etc.).
      </div>
    </div>
    <div class="step">
      <div class="step-num">3</div>
      <div class="step-text">
        Cada página realiza peticiones a la API mediante el servicio centralizado
        <span class="highlight">services/api.ts</span>, que usa <strong>fetch</strong> con tipado TypeScript.
        Todas las rutas son relativas: <span class="highlight">GET /api/projects</span>,
        <span class="highlight">GET /api/followers</span>, etc.
      </div>
    </div>
    <div class="step">
      <div class="step-num">4</div>
      <div class="step-text">
        El servidor Express recibe las peticiones, ejecuta la lógica de negocio y
        consulta o escribe en la base de datos <strong>SQLite</strong> mediante
        <span class="highlight">better-sqlite3</span>. Devuelve una respuesta JSON.
      </div>
    </div>
    <div class="step">
      <div class="step-num">5</div>
      <div class="step-text">
        Para las noticias, el servidor actúa como intermediario: comprueba si hay datos
        en <strong>caché SQLite</strong> (TTL de 30 minutos). Si han expirado, descarga
        los feeds RSS externos, los normaliza y los almacena en caché antes de responder.
      </div>
    </div>
    <div class="step">
      <div class="step-num">6</div>
      <div class="step-text">
        React actualiza el estado del componente con los datos recibidos y vuelve a renderizar
        la interfaz. Las interacciones del usuario (likes, seguidores, reseñas, visitas)
        generan nuevas peticiones que siguen el mismo ciclo.
      </div>
    </div>
  </div>

  <h3>Diagrama simplificado</h3>
  <div class="flow-box" style="font-family:'Courier New',monospace; font-size:10pt; line-height:1.9;">
    Navegador (React SPA)
    &nbsp;&nbsp;&nbsp;│
    &nbsp;&nbsp;&nbsp;├─ GET /api/projects &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ &nbsp;Express &nbsp;→ &nbsp;SQLite &nbsp;→ &nbsp;JSON
    &nbsp;&nbsp;&nbsp;├─ POST /api/projects/:id/like &nbsp;→ &nbsp;Express &nbsp;→ &nbsp;SQLite &nbsp;→ &nbsp;JSON
    &nbsp;&nbsp;&nbsp;├─ GET /api/followers &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ &nbsp;Express &nbsp;→ &nbsp;SQLite &nbsp;→ &nbsp;JSON
    &nbsp;&nbsp;&nbsp;├─ POST /api/reviews &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ &nbsp;Express &nbsp;→ &nbsp;SQLite &nbsp;→ &nbsp;JSON
    &nbsp;&nbsp;&nbsp;├─ POST /api/visits &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ &nbsp;Express &nbsp;→ &nbsp;SQLite &nbsp;→ &nbsp;JSON
    &nbsp;&nbsp;&nbsp;└─ GET /api/news &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ &nbsp;Express &nbsp;→ &nbsp;Caché SQLite
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;└─ (si expirada) → RSS externos
  </div>


  <!-- ── SECCIÓN 2 ── -->
  <h2>2. Por qué elegí SQLite</h2>

  <p>
    La elección de la base de datos fue una de las primeras decisiones técnicas del proyecto.
    Las alternativas que valoré fueron <strong>PostgreSQL</strong>, <strong>MySQL</strong> y
    <strong>SQLite</strong>. Finalmente me decanté por SQLite por las razones que explico a continuación.
  </p>

  <h3>Razones principales</h3>

  <ul>
    <li>
      <strong>Cero configuración:</strong> SQLite no requiere instalar ni configurar un servidor de base de datos
      separado. El fichero <span class="highlight">portfolio.db</span> se crea automáticamente al arrancar
      el servidor, lo que simplifica enormemente el desarrollo y el despliegue.
    </li>
    <li>
      <strong>Ideal para un portfolio personal:</strong> El volumen de datos y de usuarios concurrentes es
      muy bajo. SQLite está diseñado precisamente para aplicaciones con poca escritura concurrente,
      que es exactamente el caso de este portfolio.
    </li>
    <li>
      <strong>Facilidad de despliegue:</strong> Al ser un único fichero, no necesito provisionar
      ni pagar por un servicio externo de base de datos en Render. Todo vive en el mismo servidor.
    </li>
    <li>
      <strong>Rendimiento síncrono con better-sqlite3:</strong> La librería <span class="highlight">better-sqlite3</span>
      ofrece una API síncrona de alto rendimiento, lo que simplifica el código del backend
      eliminando la necesidad de <span class="highlight">async/await</span> en las consultas.
    </li>
    <li>
      <strong>Funcionalidades suficientes:</strong> SQLite soporta claves foráneas, restricciones
      <span class="highlight">UNIQUE</span>, <span class="highlight">CHECK</span>, modo WAL
      (Write-Ahead Logging) para concurrencia y transacciones, todo lo necesario para este proyecto.
    </li>
    <li>
      <strong>Aprendizaje:</strong> Trabajar con SQLite me ha permitido entender mejor SQL y el diseño
      de bases de datos relacionales sin la complejidad de administrar un servidor externo.
    </li>
  </ul>

  <div class="decision-box">
    <strong>Conclusión:</strong> Para un portfolio personal con tráfico moderado, SQLite es la opción
    más pragmática. Proporciona toda la potencia de SQL con la simplicidad de un fichero, sin costes
    adicionales ni infraestructura extra que gestionar.
  </div>

  <h3>Ventajas e inconvenientes</h3>

  <div class="pro-con">
    <div class="pro">
      <h4>Ventajas para este proyecto</h4>
      <ul>
        <li>Sin servidor externo que configurar</li>
        <li>Despliegue en un único servicio</li>
        <li>Código más sencillo (API síncrona)</li>
        <li>Sin coste adicional</li>
        <li>Suficiente para el volumen de datos</li>
      </ul>
    </div>
    <div class="con">
      <h4>Limitaciones a futuro</h4>
      <ul>
        <li>No escala bien con alta concurrencia</li>
        <li>En Render (plan gratuito) el fichero es efímero: se borra en cada redeploy</li>
        <li>No permite conexiones remotas múltiples</li>
        <li>Menos herramientas de administración visual</li>
      </ul>
    </div>
  </div>

  <h3>Alternativa futura</h3>
  <p>
    Si el portfolio creciera en usuarios o necesitara mayor robustez, la migración natural sería
    a <strong>PostgreSQL</strong> mediante el servicio de base de datos de Render, que ofrece
    persistencia real y mayor capacidad de concurrencia. La migración sería sencilla ya que
    la capa de acceso a datos está centralizada y el SQL utilizado es estándar.
  </p>


  <div class="footer">
    <span>Iker Martínez Velasco · 2.º DAW · DWEC · 2.ª Evaluación · Curso 2025–2026</span>
    <span>ikermartinezdev.com</span>
  </div>

</body>
</html>
